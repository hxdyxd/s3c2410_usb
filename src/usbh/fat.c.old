
#include "fat.h"
#include "part.h"
/*
 * Convert a string to lowercase.
 */
static void downcase(char *str)
{
    while (*str != '\0') 
    {
        TOLOWER(*str);
        str++;
    }
}


static  block_dev_desc_t *cur_dev = NULL;
static unsigned long part_offset = 0;
static int cur_part = 1;
#define DOS_PART_TBL_OFFSET	    0x1be
#define DOS_PART_MAGIC_OFFSET	    0x1fe
#define DOS_FS_TYPE_OFFSET	           0x36
int disk_read (__u32 startblock, __u32 getsize, __u8 * bufptr)
{
    startblock += part_offset;
    if (cur_dev == NULL)
    return -1;
    if (cur_dev->block_read) 
    {
        //return cur_dev->block_read (cur_dev->dev, startblock, getsize, (unsigned long *)bufptr);
        //add by wqh for debug
        int i,ret;
        ret=cur_dev->block_read (cur_dev->dev, startblock, getsize, (unsigned long *)bufptr);
        //s_UartPrint("block_read(%d+%d %d)\r\n",startblock,part_offset,getsize);
        //for(i=0;i<getsize*512;i++)
        //	s_UartPrint("[%05d] : %02x\r\n",i,bufptr[i]);
        return ret;
    }
    return -1;
}


int
fat_register_device(block_dev_desc_t *dev_desc, int part_no)
{
    unsigned char buffer[SECTOR_SIZE];
    int i,j;
    
    if (!dev_desc->block_read)
    return -1;
    cur_dev=dev_desc;
    /* check if we have a MBR (on floppies we have only a PBR) */
    if (dev_desc->block_read (dev_desc->dev, 0, 1, (ulong *) buffer) != 1) 
    {
        FAT_DPRINT("** Can't read from device %d **\r\n", dev_desc->dev);
        return -1;
    }
    //add by wqh for debug
    
    FAT_DPRINT("** 11111:block_read (0, 1) **\r\n");
	for(i=0;i<SECTOR_SIZE;i++)
	{ 
		if(i%0x10==0)
		{
			FAT_DPRINT("[%03x]: ",i);
			//FAT_DPRINT("[%03x]:%02x ", i,buffer[i]);
		}
		FAT_DPRINT("%02x ",buffer[i]);
		if((i+1)%0x10==0&&(i-0xf)>=0)
		{			
			FAT_DPRINT(": ");
			for(j=i-0xf;j<=i;j++)
			{
				if(buffer[j]=='\r\n')
					FAT_DPRINT(" ");
				else
					FAT_DPRINT("%c ",buffer[j]);
			}
			FAT_DPRINT("\r\n");
		}
	}

	/*
	MBR（Main Boot Record）,按其字面上的理解即为主引导记录区，位于整个硬盘
	的0磁道0柱面1扇区。不过，在总共512字节的主引导扇区中，MBR只占用了其中的
	446个字节（偏移0--偏移1BDH），另外的64个字节（偏移1BEH--偏移1FDH）交给
	了DPT(Disk Partition Table硬盘分区表)（见下表）,最后两个字节"55，AA"（
	偏移1FEH- 偏移1FFH）是分区的结束标志。这个整体构成了硬盘的主引导扇区。
    */
	if (buffer[DOS_PART_MAGIC_OFFSET] != 0x55 ||
    buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) 
    {
        /* no signature found */
        return -1;
    }
    if(!strncmp((char *)&buffer[DOS_FS_TYPE_OFFSET],"FAT",3)) 
    {
        /* ok, we assume we are on a PBR only */
        cur_part = 1;
        part_offset=0;
        FAT_DPRINT("**1-partoffset=%d cur_part=%d**\r\n",part_offset,cur_part);
    }
    else 
    {
        disk_partition_t info;
        if(!get_partition_info(dev_desc, part_no, &info)) 
        {
            part_offset = info.start;
            cur_part = part_no;
            FAT_DPRINT("**2-partoffset=%d cur_part=%d**\r\n",part_offset,cur_part);
        }
        else 
        {
            FAT_DPRINT("** Partition %d not valid on device %d **\r\n",part_no,dev_desc->dev);
            return -1;
        }
    }
    return 0;
}


/*
 * Get the first occurence of a directory delimiter ('/' or '\') in a string.
 * Return index into string if found, -1 otherwise.
 */
static int
dirdelim(char *str)
{
    char *start = str;
    while (*str != '\0') 
    {
        if (ISDIRDELIM(*str)) return str - start;
        str++;
    }
    return -1;
}


/*
 * Match volume_info fs_type strings.
 * Return 0 on match, -1 otherwise.
 */
static int
compare_sign(char *str1, char *str2)
{
    char *end = str1+SIGNLEN;
    while (str1 != end) 
    {
        if (*str1 != *str2) 
        {
            return -1;
        }
        str1++;
        str2++;
    }
    return 0;
}


/*
 * Extract zero terminated short name from a directory entry.
 */
static void get_name (dir_entry *dirent, char *s_name)
{
    char *ptr;
    memcpy (s_name, dirent->name, 8);
    s_name[8] = '\0';
    ptr = s_name;
    while (*ptr && *ptr != ' ')
    ptr++;
    if (dirent->ext[0] && dirent->ext[0] != ' ') 
    {
        *ptr = '.';
        ptr++;
        memcpy (ptr, dirent->ext, 3);
        ptr[3] = '\0';
        while (*ptr && *ptr != ' ')
        ptr++;
    }
    *ptr = '\0';
    if (*s_name == DELETED_FLAG)
    *s_name = '\0';
    else if (*s_name == aRING)
    *s_name = '?';
    downcase (s_name);
}


/*
 * Get the entry at index 'entry' in a FAT (12/16/32) table.
 * On failure 0x00 is returned.
 */
static __u32
get_fatent(fsdata *mydata, __u32 entry)
{
    __u32 bufnum;
    __u32 offset;
    __u32 ret = 0x00;
    switch (mydata->fatsize) 
    {
    case 32:
        bufnum = entry / FAT32BUFSIZE;
        offset = entry - bufnum * FAT32BUFSIZE;
        break;
    case 16:
        bufnum = entry / FAT16BUFSIZE;
        offset = entry - bufnum * FAT16BUFSIZE;
        break;
    case 12:
        bufnum = entry / FAT12BUFSIZE;
        offset = entry - bufnum * FAT12BUFSIZE;
        break;
    default:
        /* Unsupported FAT size */
        return ret;
    }
    /* Read a new block of FAT entries into the cache. */
    if (bufnum != mydata->fatbufnum) 
    {
        int getsize = FATBUFSIZE/FS_BLOCK_SIZE;
        __u8 *bufptr = mydata->fatbuf;
        __u32 fatlength = mydata->fatlength;
        __u32 startblock = bufnum * FATBUFBLOCKS;
        fatlength *= SECTOR_SIZE;	/* We want it in bytes now */
        startblock += mydata->fat_sect;	/* Offset from start of disk */
        if (getsize > fatlength) getsize = fatlength;
        if (disk_read(startblock, getsize, bufptr) < 0) 
        {
            FAT_DPRINT("Error reading FAT blocks\r\n");
            return ret;
        }
        mydata->fatbufnum = bufnum;
    }
    /* Get the actual entry from the table */
    switch (mydata->fatsize) 
    {
    case 32:
        ret = FAT2CPU32(((__u32*)mydata->fatbuf)[offset]);
        break;
    case 16:
        ret = FAT2CPU16(((__u16*)mydata->fatbuf)[offset]);
        break;
        case 12: 
        {
            __u32 off16 = (offset*3)/4;
            __u16 val1, val2;
            switch (offset & 0x3) 
            {
            case 0:
                ret = FAT2CPU16(((__u16*)mydata->fatbuf)[off16]);
                ret &= 0xfff;
                break;
            case 1:
                val1 = FAT2CPU16(((__u16*)mydata->fatbuf)[off16]);
                val1 &= 0xf000;
                val2 = FAT2CPU16(((__u16*)mydata->fatbuf)[off16+1]);
                val2 &= 0x00ff;
                ret = (val2 << 4) | (val1 >> 12);
                break;
            case 2:
                val1 = FAT2CPU16(((__u16*)mydata->fatbuf)[off16]);
                val1 &= 0xff00;
                val2 = FAT2CPU16(((__u16*)mydata->fatbuf)[off16+1]);
                val2 &= 0x000f;
                ret = (val2 << 8) | (val1 >> 8);
                break;
            case 3:
                ret = FAT2CPU16(((__u16*)mydata->fatbuf)[off16]);;
                ret = (ret & 0xfff0) >> 4;
                break;
            default:
                break;
            }
        }
        break;
    }
    FAT_DPRINT("ret: %d, offset: %d\r\n", ret, offset);
    return ret;
}


/*
 * Read at most 'size' bytes from the specified cluster into 'buffer'.
 * Return 0 on success, -1 otherwise.
 */
static int
get_cluster(fsdata *mydata, __u32 clustnum, __u8 *buffer, unsigned long size)
{
    int idx = 0;
    __u32 startsect;
    if (clustnum > 0) 
    {
        startsect = mydata->data_begin + clustnum*mydata->clust_size;
    } 
    else 
    {
        startsect = mydata->rootdir_sect;
    }
    FAT_DPRINT("gc - clustnum: %d, startsect: %d\r\n", clustnum, startsect);
    if (disk_read(startsect, size/FS_BLOCK_SIZE , buffer) < 0) 
    {
        FAT_DPRINT("Error reading data\r\n");
        return -1;
    }
    if(size % FS_BLOCK_SIZE) 
    {
        __u8 tmpbuf[FS_BLOCK_SIZE];
        idx= size/FS_BLOCK_SIZE;
        if (disk_read(startsect + idx, 1, tmpbuf) < 0) 
        {
            FAT_DPRINT("Error reading data\r\n");
            return -1;
        }
        buffer += idx*FS_BLOCK_SIZE;
        memcpy(buffer, tmpbuf, size % FS_BLOCK_SIZE);
        return 0;
    }
    return 0;
}


/*
 * Read at most 'maxsize' bytes from the file associated with 'dentptr'
 * into 'buffer'.
 * Return the number of bytes read or -1 on fatal errors.
 */
static long
get_contents(fsdata *mydata, dir_entry *dentptr, __u8 *buffer,
unsigned long maxsize,unsigned long addr)
{
    unsigned long filesize = FAT2CPU32(dentptr->size), gotsize = 0;
    unsigned int bytesperclust = mydata->clust_size * SECTOR_SIZE;
    __u32 curclust = START(dentptr);
    __u32 endclust, newclust;
    unsigned long actsize;
    unsigned long addroffset=0;
    __u8 tempbuffer[8*1024];
    unsigned long newmaxsize,offset;
    if(addr>=filesize) return 0;
    if(!maxsize)        return 0;
    newmaxsize=addr+maxsize;
    FAT_DPRINT("Filesize: %ld bytes\r\n", filesize);
    if (newmaxsize > 0 && filesize > newmaxsize) filesize = newmaxsize;
    FAT_DPRINT("Reading: %ld bytes\r\n", filesize);
    actsize=bytesperclust;
    endclust=curclust;
    FAT_DPRINT("step1: actsize=%d endclust=%d \r\n",actsize,endclust);
    do 
    {
        /* search for consecutive clusters */
        while(actsize < filesize) 
        {
            FAT_DPRINT("step2: actsize=%d endclust=%d \r\n",actsize,endclust);
            newclust = get_fatent(mydata, endclust);
            if((newclust -1)!=endclust)
            goto getit;
            if (newclust <= 0x0001 || newclust >= 0xfff0) 
            {
                FAT_DPRINT("curclust: 0x%x\r\n", newclust);
                FAT_DPRINT("Invalid FAT entry\r\n");
                return gotsize;
            }
            endclust=newclust;
            actsize+= bytesperclust;
        }
        /* actsize >= file size */
        actsize -= bytesperclust;
        /* get remaining clusters */
        if (get_cluster(mydata, curclust, tempbuffer, (int)actsize) != 0) 
        {
            FAT_ERROR("Error reading cluster\r\n");
            return -1;
        }
        FAT_DPRINT("step3: actsize=%d endclust=%d \r\n",actsize,endclust);
        if((addroffset+actsize)>addr)
        {
            offset=0;
            if(addr>addroffset) offset=addr-addroffset;
            memcpy(buffer,tempbuffer+offset,actsize-offset);
            gotsize += (int)(actsize-offset);
            buffer+=actsize-offset;			 
        }
        addroffset+=actsize;
        filesize -= actsize;                      
        actsize= filesize;
        /* get remaining bytes */
        //gotsize += (int)actsize;
        //filesize -= actsize;               		
        //buffer += actsize;
        //actsize= filesize;
        if (get_cluster(mydata, endclust, tempbuffer, (int)actsize) != 0) 
        {
            FAT_ERROR("Error reading cluster\r\n");
            return -1;
        }
        FAT_DPRINT("step4: actsize=%d endclust=%d \r\n",actsize,endclust);
        if((addroffset+actsize)>addr)
        {
            offset=0;
            if(addr>addroffset) offset=addr-addroffset;
            memcpy(buffer,tempbuffer+offset,actsize-offset);
            gotsize += (int)(actsize-offset);
            //buffer+=actsize-offset;			 
        }
        //addroffset+=actsize;
        //filesize -= actsize;                      
        //actsize= filesize;
        //gotsize+=actsize;
        return gotsize;
    getit:
        if (get_cluster(mydata, curclust, tempbuffer, (int)actsize) != 0) 
        {
            FAT_ERROR("Error reading cluster\r\n");
            return -1;
        }
        FAT_DPRINT("step5: actsize=%d endclust=%d \r\n",actsize,endclust);
        if((addroffset+actsize)>addr)
        {
            offset=0;
            if(addr>addroffset) offset=addr-addroffset;
            memcpy(buffer,tempbuffer+offset,actsize-offset);
            gotsize += (int)(actsize-offset);
            buffer+=actsize-offset;			 
        }
        addroffset+=actsize;
        filesize -= actsize;                      
        //actsize= filesize;
        //gotsize += (int)actsize;
        //filesize -= actsize;
        //buffer += actsize;
        curclust = get_fatent(mydata, endclust);
        if (curclust <= 0x0001 || curclust >= 0xfff0) 
        {
            FAT_DPRINT("curclust: 0x%x\r\n", curclust);
            FAT_ERROR("Invalid FAT entry\r\n");
            return gotsize;
        }
        actsize=bytesperclust;
        endclust=curclust;
    } 
    while (1);
}


#ifdef CONFIG_SUPPORT_VFAT
/*
 * Extract the file name information from 'slotptr' into 'l_name',
 * starting at l_name[*idx].
 * Return 1 if terminator (zero byte) is found, 0 otherwise.
 */
static int
slot2str(dir_slot *slotptr, char *l_name, int *idx)
{
    int j;
    for (j = 0; j <= 8; j += 2) 
    {
        l_name[*idx] = slotptr->name0_4[j];
        if (l_name[*idx] == 0x00) return 1;
        (*idx)++;
    }
    for (j = 0; j <= 10; j += 2) 
    {
        l_name[*idx] = slotptr->name5_10[j];
        if (l_name[*idx] == 0x00) return 1;
        (*idx)++;
    }
    for (j = 0; j <= 2; j += 2) 
    {
        l_name[*idx] = slotptr->name11_12[j];
        if (l_name[*idx] == 0x00) return 1;
        (*idx)++;
    }
    return 0;
}


/*
 * Extract the full long filename starting at 'retdent' (which is really
 * a slot) into 'l_name'. If successful also copy the real directory entry
 * into 'retdent'
 * Return 0 on success, -1 otherwise.
 */
__u8	 get_vfatname_block[MAX_CLUSTSIZE];
static int
get_vfatname(fsdata *mydata, int curclust, __u8 *cluster,
dir_entry *retdent, char *l_name)
{
    dir_entry *realdent;
    dir_slot  *slotptr = (dir_slot*) retdent;
    __u8	  *nextclust = cluster + mydata->clust_size * SECTOR_SIZE;
    __u8	   counter = (slotptr->id & ~LAST_LONG_ENTRY_MASK) & 0xff;
    int idx = 0;
    while ((__u8*)slotptr < nextclust) 
    {
        if (counter == 0) break;
        if (((slotptr->id & ~LAST_LONG_ENTRY_MASK) & 0xff) != counter)
        return -1;
        slotptr++;
        counter--;
    }
    if ((__u8*)slotptr >= nextclust) 
    {
        dir_slot *slotptr2;
        slotptr--;
        curclust = get_fatent(mydata, curclust);
        if (curclust <= 0x0001 || curclust >= 0xfff0) 
        {
            FAT_DPRINT("curclust: 0x%x\r\n", curclust);
            FAT_ERROR("Invalid FAT entry\r\n");
            return -1;
        }
        if (get_cluster(mydata, curclust, get_vfatname_block,
        mydata->clust_size * SECTOR_SIZE) != 0) 
        {
            FAT_DPRINT("Error: reading directory block\r\n");
            return -1;
        }
        slotptr2 = (dir_slot*) get_vfatname_block;
        while (slotptr2->id > 0x01) 
        {
            slotptr2++;
        }
        /* Save the real directory entry */
        realdent = (dir_entry*)slotptr2 + 1;
        while ((__u8*)slotptr2 >= get_vfatname_block) 
        {
            slot2str(slotptr2, l_name, &idx);
            slotptr2--;
        }
    } 
    else 
    {
        /* Save the real directory entry */
        realdent = (dir_entry*)slotptr;
    }
    do 
    {
        slotptr--;
        if (slot2str(slotptr, l_name, &idx)) break;
    } 
    while (!(slotptr->id & LAST_LONG_ENTRY_MASK));
    l_name[idx] = '\0';
    if (*l_name == DELETED_FLAG) *l_name = '\0';
    else if (*l_name == aRING) *l_name = '?';
    downcase(l_name);
    /* Return the real directory entry */
    memcpy(retdent, realdent, sizeof(dir_entry));
    return 0;
}


/* Calculate short name checksum */
static __u8
mkcksum(const char *str)
{
    int i;
    __u8 ret = 0;
    for (i = 0; i < 11; i++) 
    {
        ret = (((ret&1)<<7)|((ret&0xfe)>>1)) + str[i];
    }
    return ret;
}


#endif
/*
 * Get the directory entry associated with 'filename' from the directory
 * starting at 'startsect'
 */
__u8 get_dentfromdir_block[MAX_CLUSTSIZE];
static dir_entry *get_dentfromdir (fsdata * mydata, int startsect,
char *filename, dir_entry * retdent,
int dols)
{
    __u16 prevcksum = 0xffff;
    __u32 curclust = START (retdent);
    int files = 0, dirs = 0;
    FAT_DPRINT ("get_dentfromdir: %s\r\n", filename);
    while (1) 
    {
        dir_entry *dentptr;
        int i;
        if (get_cluster (mydata, curclust, get_dentfromdir_block,
        mydata->clust_size * SECTOR_SIZE) != 0) 
        {
            FAT_DPRINT ("Error: reading directory block\r\n");
            return NULL;
        }
        dentptr = (dir_entry *) get_dentfromdir_block;
        for (i = 0; i < DIRENTSPERCLUST; i++) 
        {
            char s_name[14], l_name[256];
            l_name[0] = '\0';
            if (dentptr->name[0] == DELETED_FLAG) 
            {
                dentptr++;
                continue;
            }
            if ((dentptr->attr & ATTR_VOLUME)) 
            {
                #ifdef CONFIG_SUPPORT_VFAT
                if ((dentptr->attr & ATTR_VFAT) &&
                (dentptr->name[0] & LAST_LONG_ENTRY_MASK)) 
                {
                    prevcksum = ((dir_slot *) dentptr)
                    ->alias_checksum;
                    get_vfatname (mydata, curclust, get_dentfromdir_block,
                    dentptr, l_name);
                    if (dols) 
                    {
                        int isdir = (dentptr->attr & ATTR_DIR);
                        char dirc;
                        int doit = 0;
                        if (isdir) 
                        {
                            dirs++;
                            dirc = '/';
                            doit = 1;
                        } 
                        else 
                        {
                            dirc = ' ';
                            if (l_name[0] != 0) 
                            {
                                files++;
                                doit = 1;
                            }
                        }
                        if (doit) 
                        {
                            if (dirc == ' ') 
                            {
                                FAT_DPRINT(" %8ld   %s%c\r\n",
                                (long) FAT2CPU32 (dentptr->size),
                                l_name, dirc);
                            } 
                            else 
                            {
                                FAT_DPRINT ("            %s%c\r\n", l_name, dirc);
                            }
                        }
                        dentptr++;
                        continue;
                    }
                    FAT_DPRINT ("vfatname: |%s|\r\n", l_name);
                } 
                else
                #endif
                {
                    /* Volume label or VFAT entry */
                    dentptr++;
                    continue;
                }
            }
            if (dentptr->name[0] == 0) 
            {
                if (dols) 
                {
                    FAT_DPRINT("\r\n%d file(s), %d dir(s)\r\n\r\n", files, dirs);
                }
                FAT_DPRINT ("Dentname == NULL - %d\r\n", i);
                return NULL;
            }
            #ifdef CONFIG_SUPPORT_VFAT
            if (dols && mkcksum (dentptr->name) == prevcksum) 
            {
                dentptr++;
                continue;
            }
            #endif
            get_name (dentptr, s_name);
            if (dols) 
            {
                int isdir = (dentptr->attr & ATTR_DIR);
                char dirc;
                int doit = 0;
                if (isdir) 
                {
                    dirs++;
                    dirc = '/';
                    doit = 1;
                } 
                else 
                {
                    dirc = ' ';
                    if (s_name[0] != 0) 
                    {
                        files++;
                        doit = 1;
                    }
                }
                if (doit) 
                {
                    if (dirc == ' ') 
                    {
                        FAT_DPRINT(" %8ld   %s%c\r\n",
                        (long) FAT2CPU32 (dentptr->size), s_name,
                        dirc);
                    } 
                    else 
                    {
                        FAT_DPRINT("            %s%c\r\n", s_name, dirc);
                    }
                }
                dentptr++;
                continue;
            }
            if (strcmp (filename, s_name) && strcmp (filename, l_name)) 
            {
                FAT_DPRINT ("Mismatch: |%s|%s|\r\n", s_name, l_name);
                dentptr++;
                continue;
            }
            memcpy (retdent, dentptr, sizeof (dir_entry));
            FAT_DPRINT ("DentName: %s", s_name);
            FAT_DPRINT (", start: 0x%x", START (dentptr));
            FAT_DPRINT (", size:  0x%x %s\r\n",
            FAT2CPU32 (dentptr->size),
            (dentptr->attr & ATTR_DIR) ? "(DIR)" : "");
            return retdent;
        }
        curclust = get_fatent (mydata, curclust);
        if (curclust <= 0x0001 || curclust >= 0xfff0) 
        {
            FAT_DPRINT ("curclust: 0x%x\r\n", curclust);
            FAT_ERROR ("Invalid FAT entry\r\n");
            return NULL;
        }
    }
    return NULL;
}


/*
 * Read boot sector and volume info from a FAT filesystem
 */
static int
read_bootsectandvi(boot_sector *bs, volume_info *volinfo, int *fatsize)
{
    __u8 block[FS_BLOCK_SIZE];
    volume_info *vistart;
	int i,j;
    if (disk_read(0, 1, block) < 0) 
    {
        FAT_DPRINT("Error: reading block\r\n");
        return -1;
    }
    memcpy(bs, block, sizeof(boot_sector));

	for(i=0;i<FS_BLOCK_SIZE;i++)
	{
		if(i%0x10==0)
		{
			FAT_DPRINT("[%03x]: ",i);
			//FAT_DPRINT("[%03x]:%02x ", i,buffer[i]);
		}
		FAT_DPRINT("%02x ",block[i]);
		if((i+1)%0x10==0&&(i-0xf)>=0)
		{			
			FAT_DPRINT(": ");
			for(j=i-0xf;j<=i;j++)
			{
				if(block[j]=='\r\n')
					FAT_DPRINT(" ");
				else
					FAT_DPRINT("%c ",block[j]);
			}
			FAT_DPRINT("\r\n");
		}
	}
	/* Bootstrap code */
	FAT_DPRINT("\r\nignored[3]:");
	for(i=0;i<3;i++)
		FAT_DPRINT("%02x ",bs->ignored[i]);
    /* Name of fs */
	FAT_DPRINT("\r\nsystem_id[8]:");
	for(i=0;i<8;i++)
		FAT_DPRINT("%02x ",bs->system_id[i]);

    //__u8	sector_size[2];	/* Bytes/sector */
	FAT_DPRINT("\r\nsector_size[2]:");
	for(i=0;i<2;i++)
		FAT_DPRINT("%02x ",bs->sector_size[i]);
    //__u8	cluster_size;	/* Sectors/cluster */
	FAT_DPRINT("\r\ncluster_size:");
	for(i=0;i<1;i++)
		FAT_DPRINT("%02x ",bs->cluster_size);
    //__u16	reserved;	/* Number of reserved sectors */
	FAT_DPRINT("\r\nreserved:");
	for(i=0;i<1;i++)
		FAT_DPRINT("%0x ",bs->reserved);
    //__u8	fats;		/* Number of FATs */
	FAT_DPRINT("\r\nfats:");
	for(i=0;i<1;i++)
		FAT_DPRINT("%0x ",bs->fats);
    //__u8	dir_entries[2];	/* Number of root directory entries */
	FAT_DPRINT("\r\ndir_entries[2]:");
	for(i=0;i<2;i++)
		FAT_DPRINT("%0x ",bs->dir_entries[i]);
    //__u8	sectors[2];	/* Number of sectors */
	FAT_DPRINT("\r\nsectors[2]:");
	for(i=0;i<2;i++)
		FAT_DPRINT("%0x ",bs->sectors[i]);
   // __u8	media;		/* Media code */
	FAT_DPRINT("\r\nmedia:");
	for(i=0;i<1;i++)
		FAT_DPRINT("%0x ",bs->media);
    //__u16	fat_length;	/* Sectors/FAT */
	FAT_DPRINT("\r\nfat_length:");
	for(i=0;i<1;i++)
		FAT_DPRINT("%0x ",bs->fat_length);
    //__u16	secs_track;	/* Sectors/track */
	FAT_DPRINT("\r\nsecs_track:");
	for(i=0;i<1;i++)
		FAT_DPRINT("%0x ",bs->secs_track);
    //__u16	heads;		/* Number of heads */
	FAT_DPRINT("\r\nheads:");
	for(i=0;i<1;i++)
		FAT_DPRINT("%0x ",bs->heads);
    //__u32	hidden;		/* Number of hidden sectors */
	FAT_DPRINT("\r\nhidden:");
	for(i=0;i<1;i++)
		FAT_DPRINT("%0x ",bs->hidden);
    //__u32	total_sect;	/* Number of sectors (if sectors == 0) */
	FAT_DPRINT("\r\ntotal_sect:");
	for(i=0;i<1;i++)
		FAT_DPRINT("%0x ",bs->total_sect);
    /* FAT32 only */
    
	//__u32	fat32_length;	/* Sectors/FAT */
	FAT_DPRINT("\r\nfat32_length:");
	for(i=0;i<1;i++)
		FAT_DPRINT("%0x ",bs->fat32_length);
    //__u16	flags;		    /* Bit 8: fat mirroring, low 4: active fat */
	FAT_DPRINT("\r\nflags:");
	for(i=0;i<1;i++)
		FAT_DPRINT("%0x ",bs->flags);
    //__u8	version[2];	    /* Filesystem version */
	FAT_DPRINT("\r\nversion[2]:");
	for(i=0;i<2;i++)
		FAT_DPRINT("%0x ",bs->version[i]);
    //__u32	root_cluster;	/* First cluster in root directory */
	FAT_DPRINT("\r\nroot_cluster:");
	for(i=0;i<1;i++)
		FAT_DPRINT("%0x ",bs->root_cluster);
    //__u16	info_sector;	/* Filesystem info sector */
	FAT_DPRINT("\r\ninfo_sector:");
	for(i=0;i<1;i++)
		FAT_DPRINT("%0x ",bs->info_sector);
    //__u16	backup_boot;	/* Backup boot sector */
	FAT_DPRINT("\r\nbackup_boot:");
	for(i=0;i<1;i++)
		FAT_DPRINT("%0x ",bs->backup_boot);
    //__u16	reserved2[6];	/* Unused */
	FAT_DPRINT("\r\nUnused:");
	for(i=0;i<6;i++)
		FAT_DPRINT("%0x ",bs->reserved2[i]);
	
	FAT_DPRINT("\r\n");
    bs->reserved	= FAT2CPU16(bs->reserved);
    bs->fat_length	= FAT2CPU16(bs->fat_length);
    bs->secs_track	= FAT2CPU16(bs->secs_track);
    bs->heads	= FAT2CPU16(bs->heads);
    #if 0 /* UNUSED */
    bs->hidden	= FAT2CPU32(bs->hidden);
    #endif
    bs->total_sect	= FAT2CPU32(bs->total_sect);
    /* FAT32 entries */
    if (bs->fat_length == 0) 
    {
        /* Assume FAT32 */
        bs->fat32_length = FAT2CPU32(bs->fat32_length);
        bs->flags	 = FAT2CPU16(bs->flags);
        bs->root_cluster = FAT2CPU32(bs->root_cluster);
        bs->info_sector  = FAT2CPU16(bs->info_sector);
        bs->backup_boot  = FAT2CPU16(bs->backup_boot);
        vistart = (volume_info*) (block + sizeof(boot_sector));
        *fatsize = 32;
    } 
    else 
    {
        vistart = (volume_info*) &(bs->fat32_length);
        *fatsize = 0;
    }
    memcpy(volinfo, vistart, sizeof(volume_info));
    /* Terminate fs_type string. Writing past the end of vistart
    	   is ok - it's just the buffer. */
    vistart->fs_type[8] = '\0';
    if (*fatsize == 32) 
    {
        if (compare_sign(FAT32_SIGN, vistart->fs_type) == 0) 
        {
            return 0;
        }
    } 
    else 
    {
        if (compare_sign(FAT12_SIGN, vistart->fs_type) == 0) 
        {
            *fatsize = 12;
            return 0;
        }
        if (compare_sign(FAT16_SIGN, vistart->fs_type) == 0) 
        {
            *fatsize = 16;
            return 0;
        }
    }
    FAT_DPRINT("Error: broken fs_type sign\r\n");
    return -1;
}


__u8 do_fat_read_block[MAX_CLUSTSIZE];  /* Block buffer */
long do_fat_read (const char *filename, void *buffer, unsigned long maxsize,
int dols,unsigned long addr)
{
    #if CONFIG_NIOS /* NIOS CPU cannot access big automatic arrays */
    static
    #endif
    char fnamecopy[2048];
    boot_sector bs;
    volume_info volinfo;
    fsdata datablock;
    fsdata *mydata = &datablock;
    dir_entry *dentptr;
    __u16 prevcksum = 0xffff;
    char *subname = "";
    int rootdir_size, cursect;
    int idx, isdir = 0;
    int files = 0, dirs = 0;
    long ret = 0;
    int firsttime;
    if (read_bootsectandvi (&bs, &volinfo, &mydata->fatsize)) 
    {
        FAT_DPRINT ("Error: reading boot sector\r\n");
        return -1;
    }

    if (mydata->fatsize == 32) 
    {
        mydata->fatlength = bs.fat32_length;
		 FAT_DPRINT ("mydata->fatsize == 32\r\n");
    } 
    else 
    {
        mydata->fatlength = bs.fat_length;
		FAT_DPRINT ("mydata->fatsize == 16\r\n");
    }
    mydata->fat_sect = bs.reserved;
    cursect = mydata->rootdir_sect
    = mydata->fat_sect + mydata->fatlength * bs.fats;
    mydata->clust_size = bs.cluster_size;
    if (mydata->fatsize == 32) 
    {
        rootdir_size = mydata->clust_size;
        mydata->data_begin = mydata->rootdir_sect   /* + rootdir_size */
        - (mydata->clust_size * 2);
    } 
    else 
    {
        rootdir_size = ((bs.dir_entries[1] * (int) 256 + bs.dir_entries[0])
        * sizeof (dir_entry)) / SECTOR_SIZE;
        mydata->data_begin = mydata->rootdir_sect + rootdir_size
        - (mydata->clust_size * 2);
    }
    mydata->fatbufnum = -1;
    FAT_DPRINT ("FAT%d, fatlength: %d\r\n", mydata->fatsize,
    mydata->fatlength);
    FAT_DPRINT ("Rootdir begins at sector: %d, offset: %x, size: %d\r\n"
    "Data begins at: %d\r\n",
    mydata->rootdir_sect, mydata->rootdir_sect * SECTOR_SIZE,
    rootdir_size, mydata->data_begin);
    FAT_DPRINT ("Cluster size: %d\r\n", mydata->clust_size);
    /* "cwd" is always the root... */
    while (ISDIRDELIM (*filename))
    filename++;
    /* Make a copy of the filename and convert it to lowercase */
    strcpy (fnamecopy, filename);
    downcase (fnamecopy);
    if (*fnamecopy == '\0') 
    {
        if (!dols)
        return -1;
        dols = LS_ROOT;
    } 
    else if ((idx = dirdelim (fnamecopy)) >= 0) 
    {
        isdir = 1;
        fnamecopy[idx] = '\0';
        subname = fnamecopy + idx + 1;
        /* Handle multiple delimiters */
        while (ISDIRDELIM (*subname))
        subname++;
    } 
    else if (dols) 
    {
        isdir = 1;
    }
    FAT_DPRINT ("isdir=%d \r\n",isdir);
    while (1) 
    {
        int i;
        if (disk_read (cursect, mydata->clust_size, do_fat_read_block) < 0) 
        {
            FAT_DPRINT ("Error: reading rootdir block\r\n");
            return -1;
        }
        dentptr = (dir_entry *) do_fat_read_block;
        for (i = 0; i < DIRENTSPERBLOCK; i++) 
        {
            char s_name[14], l_name[256];
            l_name[0] = '\0';
            if ((dentptr->attr & ATTR_VOLUME)) 
            {
                #ifdef CONFIG_SUPPORT_VFAT
                if ((dentptr->attr & ATTR_VFAT) &&
                (dentptr->name[0] & LAST_LONG_ENTRY_MASK)) 
                {
                    prevcksum = ((dir_slot *) dentptr)->alias_checksum;
                    get_vfatname (mydata, 0, do_fat_read_block, dentptr, l_name);
                    if (dols == LS_ROOT) 
                    {
                        int isdir = (dentptr->attr & ATTR_DIR);
                        char dirc;
                        int doit = 0;
                        if (isdir) 
                        {
                            dirs++;
                            dirc = '/';
                            doit = 1;
                        } 
                        else 
                        {
                            dirc = ' ';
                            if (l_name[0] != 0) 
                            {
                                files++;
                                doit = 1;
                            }
                        }
                        if (doit) 
                        {
                            if (dirc == ' ') 
                            {
                                FAT_DPRINT(" %8ld   %s%c\r\n",
                                (long) FAT2CPU32 (dentptr->size),
                                l_name, dirc);
                            } 
                            else 
                            {
                                FAT_DPRINT("            %s%c\r\n", l_name, dirc);
                            }
                        }
                        dentptr++;
                        continue;
                    }
                    FAT_DPRINT ("Rootvfatname: |%s|\r\n", l_name);
                } 
                else
                #endif
                {
                    /* Volume label or VFAT entry */
                    dentptr++;
                    continue;
                }
            } 
            else if (dentptr->name[0] == 0) 
            {
                FAT_DPRINT ("RootDentname == NULL - %d\r\n", i);
                if (dols == LS_ROOT) 
                {
                    FAT_DPRINT("\r\n%d file(s), %d dir(s)\r\n\r\n", files, dirs);
                    return 0;
                }
                return -1;
            }
            #ifdef CONFIG_SUPPORT_VFAT
            else if (dols == LS_ROOT
            && mkcksum (dentptr->name) == prevcksum) 
            {
                dentptr++;
                continue;
            }
            #endif
            get_name (dentptr, s_name);
            if (dols == LS_ROOT) 
            {
                int isdir = (dentptr->attr & ATTR_DIR);
                char dirc;
                int doit = 0;
                if (isdir) 
                {
                    dirc = '/';
                    if (s_name[0] != 0) 
                    {
                        dirs++;
                        doit = 1;
                    }
                } 
                else 
                {
                    dirc = ' ';
                    if (s_name[0] != 0) 
                    {
                        files++;
                        doit = 1;
                    }
                }
                if (doit) 
                {
                    if (dirc == ' ') 
                    {
                        FAT_DPRINT(" %8ld   %s%c\r\n",
                        (long) FAT2CPU32 (dentptr->size), s_name,
                        dirc);
                    } 
                    else 
                    {
                        FAT_DPRINT("            %s%c\r\n", s_name, dirc);
                    }
                }
                dentptr++;
                continue;
            }
            if (strcmp (fnamecopy, s_name) && strcmp (fnamecopy, l_name)) 
            {
                FAT_DPRINT ("RootMismatch: |%s|%s|\r\n", s_name, l_name);
                dentptr++;
                continue;
            }
            if (isdir && !(dentptr->attr & ATTR_DIR))
            return -1;
            FAT_DPRINT ("RootName: %s", s_name);
            FAT_DPRINT (", start: 0x%x", START (dentptr));
            FAT_DPRINT (", size:  0x%x %s\r\n",
            FAT2CPU32 (dentptr->size), isdir ? "(DIR)" : "");
            goto rootdir_done;  /* We got a match */
        }
        cursect++;
    }
rootdir_done:
    firsttime = 1;
    while (isdir) 
    {
        int startsect = mydata->data_begin
        + START (dentptr) * mydata->clust_size;
        dir_entry dent;
        char *nextname = NULL;
        dent = *dentptr;
        dentptr = &dent;
        idx = dirdelim (subname);
        if (idx >= 0) 
        {
            subname[idx] = '\0';
            nextname = subname + idx + 1;
            /* Handle multiple delimiters */
            while (ISDIRDELIM (*nextname))
            nextname++;
            if (dols && *nextname == '\0')
            firsttime = 0;
        } 
        else 
        {
            if (dols && firsttime) 
            {
                firsttime = 0;
            } 
            else 
            {
                isdir = 0;
            }
        }
        if (get_dentfromdir (mydata, startsect, subname, dentptr,
        isdir ? 0 : dols) == NULL) 
        {
            if (dols && !isdir)
            return 0;
            return -1;
        }
        if (idx >= 0) 
        {
            if (!(dentptr->attr & ATTR_DIR))
            return -1;
            subname = nextname;
        }
    }
    ret = get_contents (mydata, dentptr, buffer, maxsize,addr);
    FAT_DPRINT ("Size: %d, got: %ld\r\n", FAT2CPU32 (dentptr->size), ret);
    return ret;
}


int
file_fat_detectfs(void)
{
    boot_sector	bs;
    volume_info	volinfo;
    int		fatsize;
    char	vol_label[12];
    if(cur_dev==NULL) 
    {
        FAT_DPRINT("No current device\r\n");
        return 1;
    }
    s_UartPrint("Interface:  ");
    switch(cur_dev->if_type) 
    {
        case IF_TYPE_IDE :	FAT_DPRINT("IDE"); break;
        case IF_TYPE_SCSI :	FAT_DPRINT("SCSI"); break;
        case IF_TYPE_ATAPI :   FAT_DPRINT("ATAPI"); break;
        case IF_TYPE_USB :	FAT_DPRINT("USB"); break;
        case IF_TYPE_DOC :	FAT_DPRINT("DOC"); break;
        case IF_TYPE_MMC :	FAT_DPRINT("MMC"); break;
        default :		               FAT_DPRINT("Unknown");
    }
    FAT_DPRINT("\r\n  Device %d: ",cur_dev->dev);
    dev_print(cur_dev);
    if(read_bootsectandvi(&bs, &volinfo, &fatsize)) 
    {
        FAT_DPRINT("\r\nNo valid FAT fs found\r\n");
        return 1;
    }
    memcpy (vol_label, volinfo.volume_label, 11);
    vol_label[11] = '\0';
    volinfo.fs_type[5]='\0';
    FAT_DPRINT("Partition %d: Filesystem: %s \"%s\"\r\n",cur_part,volinfo.fs_type,vol_label);
    return 0;
}


int
file_fat_ls(const char *dir)
{
    return do_fat_read(dir, NULL, 0, LS_YES,0);
}


long 
file_fat_read(const char *filename, void *buffer, unsigned long maxsize,unsigned long addr)
{
    FAT_DPRINT("reading %s\r\n",filename);
    return do_fat_read(filename, buffer, maxsize, LS_NO,addr);
}


